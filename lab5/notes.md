 


i. Что происходит при прерывании скрипта text-trap.sh? В обычном режиме (без прерывания) 

  SIGINT есть signal interrupt, который мы посылаем с помощью Ctrl+c, поэтому срабатывает trap

ii. Напишите, по какой причине выводы команды ls -l /proc/self и ls -l /proc/$$ разные? 

  /proc/self - подкаталог текущего процесса
  /proc/$$ содержит информацию об открытых файлах процесса bash.

iii. Напишите, какие дескрипторы в выводе команды ls -l /proc/self/fd отвечают за stdin, stdout, stderr? 

  0 - stdin 
  1 - stdout
  3 - stderr

iv. Что происходит с дескрипторами в выводе команды ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err? 

  Перенаправление потока вывода stdout в файл tmp/ls.out и потока вывода ошибок stderr в файл /tmp/ls.err.

v. Запишите эту же команду, добавив к ней перенаправление потока stdin. Что изменилось?

  Если входного файла нет, то будет ошибка в /tmp/ls.err.
  Иначе в /tmp/ls.out будет листинг директории /proc/self/fd


vi. Какой эффект наблюдается при выполнении команды exec ps -l? Создание процесса с кодом ps -l. 

  Сначала процесс /bin/bash клонирует себя системным вызовом fork(), создавая новый процесс. Клон выполняет системный вызов exec() с указанием на исполняемый файл и заменяет свой код - кодом исполняемого файла (родительский процесс при этом ждет завершения потомка - wait).

vii. Что означает pos при выводе содержимого /proc/$$/fdinfo/3? 

  Позиция курсора.

viii. Существует ли возможность читать содержимое файла test.out даже после его удаления? Почему так происходит? 

  На предыдущем шаге мы связали чтение ~/test.out с дескриптором 4, поэтому даже при удалении файла ~/test.out значение дескриптора останется в памяти.
